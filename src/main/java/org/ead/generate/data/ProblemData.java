package org.ead.generate.data;

import org.ead.generate.ProblemGenerationConfiguration;
import org.ead.generate.types.IGenerateDataType;
import org.ead.generate.types.PreGeneratedListGenerator;

import java.util.*;

/**
 * Class that generates and stores the actual data that is generated by all data types.
 * The class is also responsible for checking global and local constraints during the generation process.
 * @author Markus Ullrich
 */
public class ProblemData {

    private static final int RESET_COUNTER = 100; //TODO: make this configurable
    private HashMap<String, List<String>> data;
    private HashMap<String, IGenerateDataType> types;
    private ProblemGenerationConfiguration configuration;

    private static final int MAX_TRIES = 1000; //TODO: make this configurable

    public ProblemData() {
        this.types = new HashMap<>();
        this.data = new HashMap<>();
    }

    public void setConfiguration(ProblemGenerationConfiguration configuration) {
        this.configuration = configuration;
    }

    public ProblemGenerationConfiguration getConfiguration() {
        return this.configuration;
    }

    public void addDataType(IGenerateDataType dataType) {
        this.types.put(dataType.getName(), dataType);
        this.data.put(dataType.getName(), new ArrayList<String>());
    }

    public void generateData(List<ProblemGenerationConstraint> constraints, IGenerateDataType[] order) {
        int index = 0;
        IGenerateDataType currentType;
        boolean[] potentialDuplicateRows = new boolean[this.data.get(order[index].getName()).size()];
        for (int row = 0 ; row < potentialDuplicateRows.length ; row++) {
            potentialDuplicateRows[row] = true;
        }
        while(index < order.length) {
            currentType = order[index];
            int tries = ProblemData.MAX_TRIES;
            boolean constraintsFulfilled = false;
            String value = "";
            while(!constraintsFulfilled) {
                tries--;
                constraintsFulfilled = true;
                value = currentType.generateValue();
                for (ProblemGenerationConstraint constraint : constraints) {
                    if (constraint.getLeft().getDataTypeName().equals(currentType.getName())) {
                        constraintsFulfilled &= constraint.isStillPossible(configuration.getNumberOfRows() - (this.data.get(currentType.getName()).size()), this, value);
                    }
                }
                String typeName = order[index].getName();
                if (this.configuration.isNoDuplicates()) {
                    boolean[] potentialDuplicateCopy = Arrays.copyOf(potentialDuplicateRows, potentialDuplicateRows.length);
                    boolean atLeastOneDuplicate = false;
                    int potentialDuplicateRowCount = 0;
                    for (int row = 0; row < potentialDuplicateRows.length; row++) {
                        String valueForType = this.data.get(typeName).get(row);
                        potentialDuplicateRows[row] &= value.equals(valueForType);
                        atLeastOneDuplicate |= potentialDuplicateRows[row];
                        if (potentialDuplicateRows[row]) {
                            potentialDuplicateRowCount++;
                        }
                    }
                    if (atLeastOneDuplicate) {
                        boolean duplicateNotPreventable = true;
                        long potentialCombinations = 0;
                        for (int secondIndex = index + 1; secondIndex < order.length; secondIndex++) {
                            long secondTotalDistinctValues = order[secondIndex].getTotalDistinctValues();
                            for (ProblemGenerationConstraint constraint : constraints) {
                                if (constraint.getRelation() == ProblemGenerationConstraint.Relation.E  &&
                                        (order[secondIndex].getName().equals(constraint.getLeft().getDataTypeName())) ||
                                        order[secondIndex].getName().equals(constraint.getLeft().getSecondDataTypeName())) {
                                    secondTotalDistinctValues = 1;
                                }
                            }
                            if (secondTotalDistinctValues > potentialDuplicateRowCount) {
                                //TODO: find more useful location (reuse this code)
                                duplicateNotPreventable = false;
                                break;
                            }
                            if (potentialCombinations == 0) {
                                potentialCombinations += secondTotalDistinctValues;
                            } else {
                                potentialCombinations *= secondTotalDistinctValues;
                            }
                        }
                        duplicateNotPreventable &= potentialCombinations <= potentialDuplicateRowCount;
                        constraintsFulfilled &= !duplicateNotPreventable;
                        if (duplicateNotPreventable) {
                            potentialDuplicateRows = Arrays.copyOf(potentialDuplicateCopy, potentialDuplicateCopy.length);
                        }
                    }
                }
                if (!constraintsFulfilled) {
                    if (tries == 0) {
                        throw new IllegalStateException("No possible value for the current type (" + typeName + ") could be generated after " + MAX_TRIES + " tries.");
                    } else {
                        currentType.resetLastValue();
                        if (tries % RESET_COUNTER == 0 && currentType instanceof PreGeneratedListGenerator) {
                            ((PreGeneratedListGenerator) currentType).shuffleRemainingValues();
                        }
                    }
                }
            }
            this.data.get(currentType.getName()).add(value);
            index++;
        }
    }

    public Set<String> getDataTypes(){
        return this.data.keySet();
    }

    @SuppressWarnings("unused")
    public List<String> getValuesForName(String name) {
        return this.data.get(name);
    }

    public String getLastValueFor(String dataTypeName) {
        if (this.data.containsKey(dataTypeName)) {
            if (this.data.get(dataTypeName).size() == 0)
                return null;
            return this.data.get(dataTypeName).get(data.get(dataTypeName).size() - 1);
        }
        return null;
    }

    public IGenerateDataType getTypeForName(String name) {
        return this.types.get(name);
    }

}
