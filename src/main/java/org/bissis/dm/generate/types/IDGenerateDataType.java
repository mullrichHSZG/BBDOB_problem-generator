package org.bissis.dm.generate.types;

/**
 * This class represents an ID data type.
 * Useful if the generated results should contain an ID column
 * or if it should be prevented that the generated value at a time
 * is always larger than the previous one.
 * @author Markus Ullrich
 */
public class IDGenerateDataType extends NumericDataType {

    private final long initialStart;
    private long startValue = 0;
    private long stepValue = 1;

    /**
     * Creates a new {@link IDGenerateDataType}
     * @param typeName - the name of this data type
     * @param startValue - the first value that will be generated by this data type
     */
    public IDGenerateDataType(String typeName, long startValue) {
        super(typeName);
        this.startValue = startValue;
        this.initialStart = startValue;
    }

    /**
     * Creates a new {@link IDGenerateDataType}
     * @param typeName - the name of this data type
     * @param startValue - the first value that will be generated by this data type
     * @param stepValue - the increment for the next value - must not be negative or zero
     * @throws IllegalArgumentException - if the stepValue is negative or zero
     */
    public IDGenerateDataType(String typeName, long startValue, long stepValue) {
        super(typeName);
        this.startValue = startValue;
        this.initialStart = startValue;
        if (stepValue <= 0) {
            throw new IllegalArgumentException("The stepValue must not be negative or zero.");
        }
        this.stepValue = stepValue;
    }

    @Override
    public String generateValue() {
        long value = startValue;
        startValue += stepValue;
        return "" + value;
    }

    @Override
    public String getDefaultValue() {
        return "" +  startValue;
    }

    @Override
    public void resetLastValue() {
        this.startValue -= this.stepValue;
    }

    @Override
    public long getTotalDistinctValues() {
        return (Long.MAX_VALUE - this.startValue) / this.stepValue;
    }

    @Override
    public long getNextDistinctValues() {
        return 1;
    }

    @Override
    public double getTotalUpperBound() {
        return Long.MAX_VALUE - (Long.MAX_VALUE % this.stepValue);
    }

    @Override
    public double getTotalLowerBound() {
        return this.initialStart;
    }

    @Override
    public double getNextUpperBound() {
        return this.startValue + this.stepValue;
    }

    @Override
    public double getNextLowerBound() {
        return this.startValue + this.stepValue;
    }

    @Override
    public boolean allowIntegersOnly() {
        return true;
    }
}
