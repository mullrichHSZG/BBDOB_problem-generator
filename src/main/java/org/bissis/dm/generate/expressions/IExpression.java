package org.bissis.dm.generate.expressions;

import org.bissis.dm.generate.data.ProblemData;

/**
 * Interface for all expressions that can be used by either data types or constraints.
 * @author Markus Ullrich
 */
public interface IExpression {

    /**
     * Evaluates the expression for the given values and returns the result as a String value.
     * @param value - the value for the first data type
     * @param secondValue - the value for the second data type
     * @return the evaluation result
     */
    String evaluate(String value, String secondValue);

    /**
     * Returns the expression as a String value
     * @return the expression
     */
    String getExpression();

    /**
     * Returns the name of the data type used in this expression.
     * @return the data type name
     */
    String getDataTypeName();

    /**
     * The name of the second data type used in this expression if present. Otherwise this method should return null.
     * @return the name of the second data type
     */
    String getSecondDataTypeName();

    /**
     * The minimum value that can be generated by this expression based on the boundaries of the involved data types.
     * @param problemData - the problem data which contains the data types
     * @return the lowest possible value for this expression
     */
    double getMinValue(ProblemData problemData);

    /**
     * The maximum value that can be generated by this expression based on the boundaries of the involved data types.
     * @param problemData - the problem data which contains the data types
     * @return the highest possible value for this expression
     */
    double getMaxValue(ProblemData problemData);

    /**
     * The next minimum value that can be generated by this expression based on the boundaries of the involved data types.
     * @param problemData - the problem data which contains the data types
     * @return the lowest possible value for this expression for the next generation cycle
     */
    double getNextMinValue(ProblemData problemData);

    /**
     * The next maximum value that can be generated by this expression based on the boundaries of the involved data types.
     * @param problemData - the problem data which contains the data types
     * @return the highest possible value for this expression for the next generation cycle
     */
    double getNextMaxValue(ProblemData problemData);

}
